# ------------------------------
# File: main.c
# ------------------------------

import re
import os
import sys
import random
import argparse
import matplotlib.pyplot as plt
from typing import Tuple, List, Dict

from core.agent import Agent, AGENT_TYPE_MEDICINE, AGENT_TYPE_FOOD
from core.task import Task, TASK_TYPE_MEDICINE, TASK_TYPE_FOOD
from core.topology import Topology
from core.environment import Environment
from algorithms.factory import AlgorithmFactory
from visualization.animator import Animator

# Defaults
NUM_AGENTS = 6 
NUM_TASKS = 12 
NETWORK = 'row'
MAX_TASKS = 3
MAX_TIME = 5000.0
FIELD_SIZE = 2000.0
MAX_ITER = 100
RADIUS = 300.0 
DT = 2.0 

# ********************************** 
# IO Helpers (Ported from V2)
# ********************************** 
def ensure_data_prefix(filename):
    if not os.path.dirname(filename):
        return os.path.join('data', filename)
    else:
        return filename

def save_info_to_file(tasks: List[Task], agents: List[Agent], filename: str):
    """
    Saves the current simulation configuration to a text file.

    Writes task and agent positions, deadlines, and execution durations to the
    specified file path. This allows for reproducing specific random scenarios.

    Args:
        tasks: A list of Task objects present in the simulation.
        agents: A list of Agent objects present in the simulation.
        filename: The target file path to write the configuration to.

    Raises:
        IOError: If the file cannot be opened or written to.
    """
    try:
        with open(filename, 'w') as f:
            f.write('--- Tasks Info ---\n')
            for task in tasks:
                f.write(f"pos: ({task.position[0]}, {task.position[1]}), "
                        f"deadline: {task.deadline}, "
                        f"duration: {task.exec_duration}\n")

            f.write('--- Agents Info ---\n')
            for agent in agents:
                f.write(f"pos: ({agent.position[0]}, {agent.position[1]})\n")
        print(f"Successfully saved scenario to '{filename}'.")
    except IOError as e:
        print(f"Error saving file: {e}", file=sys.stderr)

def load_info_from_file(filename: str) -> Tuple[List[Dict], List[Dict]]:
    """
    Parses simulation configuration from a saved text file.

    Reads a file generated by `save_info_to_file` and extracts task and agent
    initialization parameters using regular expressions.

    Args:
        filename: The path to the configuration file.

    Returns:
        A tuple containing two lists:
            - task_infos (List[Dict]): A list of dictionaries, each containing
              'pos', 'deadline', and 'duration' for a task.
            - agent_infos (List[Dict]): A list of dictionaries, each containing
              'pos' for an agent.

    Raises:
        SystemExit: If the file cannot be found or read (exits the program).
    """
    task_infos = []
    agent_infos = []
    mode = ''
    
    # Regex patterns
    task_pat = r'pos:\s*\(\s*(\d+\.?\d*),\s*(\d+\.?\d*)\s*\),\s*deadline:\s*(\d+\.?\d*),\s*duration:\s*(\d+\.?\d*)'
    agent_pat = r'pos:\s*\(\s*(\d+\.?\d*),\s*(\d+\.?\d*)\s*\)'

    try:
        with open(filename, 'r') as f:
            for line in f:
                line = line.strip()
                if line == "--- Tasks Info ---":
                    mode = 'task'
                    continue
                elif line == "--- Agents Info ---":
                    mode = 'agent'
                    continue

                if mode == 'task':
                    m = re.search(task_pat, line)
                    if m:
                        task_infos.append({
                            'pos': (float(m.group(1)), float(m.group(2))),
                            'deadline': float(m.group(3)),
                            'duration': float(m.group(4))
                        })
                elif mode == 'agent':
                    m = re.search(agent_pat, line)
                    if m:
                        agent_infos.append({
                            'pos': (float(m.group(1)), float(m.group(2)))
                        })
        print(f"Successfully loaded {len(task_infos)} tasks and {len(agent_infos)} agents from '{filename}'.")
    except IOError as e:
        print(f"Error loading file: {e}", file=sys.stderr)
        sys.exit(1)
        
    return task_infos, agent_infos

def setup_manual_network(adj_matrix: List[List[bool]], num_agents: int, net_type: str) -> None:
    """
    Sets up the adjacency matrix based on a fixed topology pattern.
    """
    if net_type == 'full':
        for i in range(num_agents):
            for j in range(i + 1, num_agents):
                adj_matrix[i][j] = adj_matrix[j][i] = True
    
    elif net_type == 'row':
        # A-B-C-D-E
        for i in range(num_agents - 1):
            adj_matrix[i][i+1] = adj_matrix[i+1][i] = True
            
    elif net_type == 'star':
        # Center is 0
        for i in range(1, num_agents):
            adj_matrix[0][i] = adj_matrix[i][0] = True
            
    elif net_type == 'circle':
        # Ring
        for i in range(num_agents - 1):
            adj_matrix[i][i+1] = adj_matrix[i+1][i] = True
        adj_matrix[0][num_agents-1] = adj_matrix[num_agents-1][0] = True

# ********************************** 
# Scenario Setup
# ********************************** 
def _create_agent_objects(agent_data: List[Dict], args, tasks: List[Task]) -> List[Agent]:
    """
    Instantiates Agent objects and injects the selected algorithm strategy.

    This helper iterates through agent initialization data, assigns types (Medicine/Food)
    based on index, creates the specified algorithm instance via the factory, and
    binds the agent to the algorithm.

    Args:
        agent_data: A list of dictionaries containing initial positions for agents.
        args: Parsed command-line arguments containing simulation parameters.
        tasks: The global list of tasks (required for algorithm initialization).

    Returns:
        List[Agent]: A list of fully initialized Agent objects.
    """
    agents = []
    cmap = plt.get_cmap('viridis')
    num_agents = len(agent_data)

    for i, info in enumerate(agent_data):
        # Determine properties based on index (Medicine vs Food)
        if i < num_agents / 2:
            a_type = AGENT_TYPE_MEDICINE
            speed = 30.0
        else:
            a_type = AGENT_TYPE_FOOD
            speed = 50.0
        
        color = cmap(i / (num_agents - 1)) if num_agents > 1 else cmap(0.5)
        pos = info['pos']

        # Create Algorithm Strategy
        algo = AlgorithmFactory.create(args.algorithm, i, args.max_tasks_per_agent, tasks)
        
        # Create Agent
        new_agent = Agent(
            id=i, agent_type=a_type, position=pos, speed=speed, 
            color=color, algorithm=algo
        )
        
        # Bind agent back to algorithm
        algo.bind_agent(new_agent)
        agents.append(new_agent)
        
    return agents

def setup_scenario(args) -> Tuple[List[Task], List[Agent], Topology]:
    """
    Sets up the complete simulation scenario including tasks, agents, and topology.

    This function handles two modes of initialization:
    1. Random Generation: Creates tasks and agents with random positions if no load file is specified.
    2. File Loading: Reconstructs the scenario from a saved configuration file.

    It also handles the 'save' functionality if requested.

    Args:
        args: Parsed command-line arguments.

    Returns:
        Tuple[List[Task], List[Agent], Topology]: A tuple containing the lists of
        created tasks and agents, and the initialized topology object.
    """
    tasks = []
    agent_data_list = [] # Intermediate storage for agent positions

    # --- Branch 1: Load from File ---
    if args.load:
        t_infos, a_infos = load_info_from_file(args.file)
        
        # 1. Reconstruct Tasks
        for i, info in enumerate(t_infos):
            t_type = TASK_TYPE_MEDICINE if i < len(t_infos) / 2 else TASK_TYPE_FOOD
            tasks.append(Task(
                id=i, task_type=t_type, position=info['pos'],
                deadline=info['deadline'], exec_duration=info['duration']
            ))
        
        # 2. Prepare Agent Data
        agent_data_list = a_infos

    # --- Branch 2: Generate Random ---
    else:
        # 1. Generate Tasks
        for i in range(args.tasks):
            t_type = TASK_TYPE_MEDICINE if i < args.tasks / 2 else TASK_TYPE_FOOD
            tasks.append(Task(
                id=i, task_type=t_type,
                position=(random.uniform(0, FIELD_SIZE), random.uniform(0, FIELD_SIZE)),
                deadline=random.uniform(0, 2000),
                exec_duration=random.uniform(50, 100)
            ))
        
        # 2. Generate Agent Positions
        for i in range(args.agents):
            pos = (random.uniform(0, FIELD_SIZE), random.uniform(0, FIELD_SIZE))
            agent_data_list.append({'pos': pos})

    # --- Common: Instantiate Agents & Algorithms ---
    # Note: We need 'tasks' to exist before creating algorithms
    agents = _create_agent_objects(agent_data_list, args, tasks)

    # --- Save if requested (and not loading) ---
    if args.save and not args.load:
        filename = ensure_data_prefix(args.file)
        save_info_to_file(tasks, agents, filename)

    # --- Common: Finalize Setup ---
    # 1. Setup Feasibility (Global Info)
    feasibility = [[False] * len(tasks) for _ in range(len(agents))]
    for i, agent in enumerate(agents):
        for j, task in enumerate(tasks):
            if agent.agent_type == task.task_type:
                feasibility[i][j] = True
    
    for agent in agents:
        agent.algorithm.finalize_setup(feasibility)

    # 2. Topology
    topology = Topology([a.id for a in agents])

    if args.network != 'radius':
        num = len(agents)
        adj = [[False] * num for _ in range(num)]
        setup_manual_network(adj, num, args.network)
        topology.update_from_adjacency_matrix(adj)
        print(f">>> Topology initialized as '{args.network}'")
    else:
        print(f">>> Topology will be calculated by Radius ({args.radius})")
    
    return tasks, agents, topology

def parse_args():
    """
    Parses command-line arguments.

    Defines and parses all available flags for simulation configuration, algorithm
    selection, and input/output control.

    Returns:
        argparse.Namespace: An object containing the values of all command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Unified MRTA Simulation Framework")
    
    # Algorithm Selection
    parser.add_argument("--algo", dest="algorithm", type=str, default="v2", 
                        choices=["original", "v1", "v2", "v3"], help="Algorithm strategy to use.")
    
    # Simulation Config
    parser.add_argument("-a", "--agents", type=int, default=NUM_AGENTS, help="Number of agents")
    parser.add_argument("-t", "--tasks", type=int, default=NUM_TASKS, help="Number of tasks")
    parser.add_argument("-r", "--radius", type=float, default=RADIUS, help="Comm radius")
    parser.add_argument("-m", "--max-tasks-per-agent", type=int, default=MAX_TASKS, help="Capacity constraint")
    parser.add_argument("-i", "--max-iterations", type=int, default=MAX_ITER, help="Max iterations for static allocation")
    parser.add_argument("--network", type=str, default='row', choices=['radius', 'row', 'star', 'circle', 'full'], help="Network topology type.")
    
    # IO & Control Flags
    parser.add_argument("--save", action="store_true", help="Save scenario to file")
    parser.add_argument("--load", action="store_true", help="Load scenario from file")
    parser.add_argument("--file", type=str, default="scenario_info.txt", help="Filename for save/load")
    parser.add_argument("--quiet", action="store_true", help="Run without visualization (Console only)")

    return parser.parse_args()

# ********************************** 
# Main Entry
# ********************************** 
if __name__ == "__main__":
    args = parse_args()
    
    # 1. Setup
    tasks, agents, topology = setup_scenario(args)
    is_fixed_topology = (args.network != 'radius')
    env = Environment(
        agents, 
        tasks, 
        topology, 
        args.radius, 
        fixed_topology=is_fixed_topology 
    )

    # 2. Select Generator Mode
    if args.algorithm == "original":
        print(">>> Mode: Static Allocation + Execution (Original PI)")

        def chained_generator():
            # Phase 1
            yield from env.run_static_allocation(args.max_iterations)
            # Phase 2
            yield from env.run_static_execution(DT, MAX_TIME)
        generator = chained_generator()
        
    else: # v1 or v2
        print(f">>> Mode: Dynamic Simulation ({args.algorithm})")
        generator = env.run_dynamic_simulation(DT, MAX_TIME)

    # 3. Run
    if args.quiet:
        print("Running in quiet mode...")
        for _ in generator: 
            pass
        print("Simulation finished.")
    else:
        # Pass environment to animator for access to static info if needed
        animator = Animator(env, generator, args.radius)
        animator.run()
